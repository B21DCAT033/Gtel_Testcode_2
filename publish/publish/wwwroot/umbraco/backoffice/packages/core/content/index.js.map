{"version":3,"file":"index.js","sources":["../../../../src/packages/core/content/conditions/has-properties/constants.ts","../../../../src/packages/core/content/constants.ts","../../../../src/packages/core/content/controller/merge-content-variant-data.controller.ts","../../../../src/packages/core/content/manager/element-data-manager.ts","../../../../src/packages/core/content/manager/content-data-manager.ts","../../../../src/packages/core/content/property-dataset-context/content-property-dataset.context-token.ts","../../../../src/packages/core/content/property-dataset-context/element-property-dataset.context.ts","../../../../src/packages/core/content/property-dataset-context/content-property-dataset.context.ts","../../../../src/packages/core/content/workspace/content-detail-workspace-base.ts"],"sourcesContent":["export const UMB_CONTENT_HAS_PROPERTIES_WORKSPACE_CONDITION = 'Umb.Condition.Workspace.ContentHasProperties';\r\n","export const UMB_CONTENT_SECTION_ALIAS = 'Umb.Section.Content';\r\nexport * from './workspace/constants.js';\r\nexport * from './conditions/constants.js';\r\n","import type { UmbContentLikeDetailModel, UmbPotentialContentValueModel } from '../types.js';\r\nimport { UmbControllerBase } from '@umbraco-cms/backoffice/class-api';\r\nimport { createExtensionApi } from '@umbraco-cms/backoffice/extension-api';\r\nimport { umbExtensionsRegistry } from '@umbraco-cms/backoffice/extension-registry';\r\nimport { UmbVariantId, type UmbVariantDataModel } from '@umbraco-cms/backoffice/variant';\r\n\r\n/**\r\n * @function defaultCompareVariantMethod\r\n * @param {UmbVariantDataModel} a - the first variant to compare.\r\n * @param {UmbVariantDataModel} b - the second variant to compare.\r\n * @returns {boolean} - true if the two models are equally unique.\r\n */\r\nfunction defaultCompareVariantMethod(a: UmbVariantDataModel, b: UmbVariantDataModel) {\r\n\treturn a.culture === b.culture && a.segment === b.segment;\r\n}\r\n\r\nexport class UmbMergeContentVariantDataController extends UmbControllerBase {\r\n\t/**\r\n\t * Merges content variant data based on selected variants and variants to store.\r\n\t * @param {UmbContentLikeDetailModel | undefined} persistedData - The persisted content variant data.\r\n\t * @param {UmbContentLikeDetailModel} currentData - The current content variant data.\r\n\t * @param {Array<UmbVariantId>} selectedVariants - The selected variants.\r\n\t * @param {Array<UmbVariantId>} variantsToStore - The variants to store, we sometimes have additional variants that we like to process. This is typically the invariant variant, which we do not want to have as part of the variants data therefore a difference.\r\n\t * @returns {Promise<UmbContentLikeDetailModel>} - A promise that resolves to the merged content variant data.\r\n\t */\r\n\tasync process<ModelType extends UmbContentLikeDetailModel>(\r\n\t\tpersistedData: ModelType | undefined,\r\n\t\tcurrentData: ModelType,\r\n\t\tselectedVariants: Array<UmbVariantId>,\r\n\t\tvariantsToStore: Array<UmbVariantId>,\r\n\t): Promise<ModelType> {\r\n\t\t// Combine data and persisted data depending on the selectedVariants. Always use the invariant values from the data.\r\n\t\t// loops over each entry in values, determine wether the value should be from the data or the persisted data, depending on wether its a selectedVariant or an invariant value.\r\n\t\t// loops over each entry in variants, determine wether the variant should be from the data or the persisted data, depending on the selectedVariants.\r\n\t\tconst result = { ...currentData };\r\n\t\tresult.values = await this.#processValues<ModelType['values'][0]>(\r\n\t\t\tpersistedData?.values,\r\n\t\t\tcurrentData.values,\r\n\t\t\tvariantsToStore,\r\n\t\t);\r\n\r\n\t\tif (currentData.variants) {\r\n\t\t\t// Notice for variants we do not want to include all the variants that we are processing. but just the once selected for the process. (Not include invariant if we are in a variant document) [NL]\r\n\t\t\tresult.variants = this.#processVariants(\r\n\t\t\t\tpersistedData?.variants,\r\n\t\t\t\tcurrentData.variants,\r\n\t\t\t\tselectedVariants,\r\n\t\t\t\tdefaultCompareVariantMethod,\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tthis.destroy();\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * Builds and saves values based on selected variants and variants to store.\r\n\t * @param {Array<UmbPotentialContentValueModel> | undefined} persistedValues - The persisted values.\r\n\t * @param {Array<UmbPotentialContentValueModel> | undefined} draftValues - The draft values.\r\n\t * @param {Array<UmbVariantId>}variantsToStore - The variants to store.\r\n\t * @returns {Promise<Array<UmbPotentialContentValueModel>>} - A promise that resolves to the saved values.\r\n\t */\r\n\tasync #processValues<T extends UmbPotentialContentValueModel = UmbPotentialContentValueModel>(\r\n\t\tpersistedValues: Array<T> | undefined,\r\n\t\tdraftValues: Array<T> | undefined,\r\n\t\tvariantsToStore: Array<UmbVariantId>,\r\n\t): Promise<Array<T>> {\r\n\t\t// Make array of unique values, based on persistedValues and draftValues. Both alias, culture and segment has to be taken into account. [NL]\r\n\r\n\t\tconst uniqueValues = [...(persistedValues ?? []), ...(draftValues ?? [])].filter(\r\n\t\t\t(n, i, self) =>\r\n\t\t\t\ti === self.findIndex((v) => v.alias === n.alias && v.culture === n.culture && v.segment === n.segment),\r\n\t\t);\r\n\r\n\t\t// Map unique values to their respective draft values.\r\n\t\treturn (\r\n\t\t\tawait Promise.all(\r\n\t\t\t\tuniqueValues.map((value) => {\r\n\t\t\t\t\tconst persistedValue = persistedValues?.find(\r\n\t\t\t\t\t\t(x) => x.alias === value.alias && x.culture === value.culture && x.segment === value.segment,\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t// Should this value be saved?\r\n\t\t\t\t\tif (variantsToStore.some((x) => x.equal(UmbVariantId.CreateFromPartial(value)))) {\r\n\t\t\t\t\t\tconst draftValue = draftValues?.find(\r\n\t\t\t\t\t\t\t(x) => x.alias === value.alias && x.culture === value.culture && x.segment === value.segment,\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\treturn this.#processValue(persistedValue, draftValue, variantsToStore);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// TODO: Check if this promise is needed: [NL]\r\n\t\t\t\t\t\treturn Promise.resolve(persistedValue);\r\n\t\t\t\t\t}\r\n\t\t\t\t}),\r\n\t\t\t)\r\n\t\t).filter((x) => x !== undefined) as Array<T>;\r\n\t}\r\n\r\n\t/**\r\n\t * Builds and saves a value based on selected variants and variants to store.\r\n\t * @param {UmbPotentialContentValueModel | undefined} persistedValue - The persisted value.\r\n\t * @param {UmbPotentialContentValueModel | undefined} draftValue - The draft value.\r\n\t * @param {Array<UmbVariantId>} variantsToStore - The variants to store.\r\n\t * @returns {Promise<UmbPotentialContentValueModel | undefined>} A promise that resolves to the saved value.\r\n\t */\r\n\tasync #processValue(\r\n\t\tpersistedValue: UmbPotentialContentValueModel | undefined,\r\n\t\tdraftValue: UmbPotentialContentValueModel | undefined,\r\n\t\tvariantsToStore: Array<UmbVariantId>,\r\n\t): Promise<UmbPotentialContentValueModel | undefined> {\r\n\t\tconst editorAlias = draftValue?.editorAlias ?? persistedValue?.editorAlias;\r\n\t\tif (!editorAlias) {\r\n\t\t\tconsole.error(`Editor alias not found for ${editorAlias}`);\r\n\t\t\treturn draftValue;\r\n\t\t}\r\n\t\tif (!draftValue) {\r\n\t\t\t// If the draft value does not exists then no need to process.\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\t// Find the resolver for this editor alias:\r\n\t\tconst manifest = umbExtensionsRegistry.getByTypeAndFilter(\r\n\t\t\t'propertyValueResolver',\r\n\t\t\t// TODO: Remove depcrated filter in v.17 [NL]\r\n\t\t\t(x) => x.forEditorAlias === editorAlias || x.meta?.editorAlias === editorAlias,\r\n\t\t)[0];\r\n\r\n\t\tif (!manifest) {\r\n\t\t\t// No resolver found, then we can continue using the draftValue as is.\r\n\t\t\treturn draftValue;\r\n\t\t}\r\n\r\n\t\tconst api = await createExtensionApi(this, manifest);\r\n\t\tif (!api) {\r\n\t\t\t// If api is not to be found, then we can continue using the draftValue as is.\r\n\t\t\treturn draftValue;\r\n\t\t}\r\n\r\n\t\tlet newValue = draftValue;\r\n\r\n\t\tif (api.processValues) {\r\n\t\t\t// The a property values resolver resolves one value, we need to gather the persisted inner values first, and store them here:\r\n\t\t\tconst persistedValuesHolder: Array<Array<UmbPotentialContentValueModel>> = [];\r\n\r\n\t\t\tif (persistedValue) {\r\n\t\t\t\tawait api.processValues(persistedValue, async (values) => {\r\n\t\t\t\t\tpersistedValuesHolder.push(values as unknown as Array<UmbPotentialContentValueModel>);\r\n\t\t\t\t\treturn undefined;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tlet valuesIndex = 0;\r\n\t\t\tnewValue =\r\n\t\t\t\t(await api.processValues(newValue, async (values) => {\r\n\t\t\t\t\t// got some values (content and/or settings):\r\n\t\t\t\t\t// but how to get the persisted and the draft of this.....\r\n\t\t\t\t\tconst persistedValues = persistedValuesHolder[valuesIndex++];\r\n\r\n\t\t\t\t\treturn await this.#processValues(persistedValues, values, variantsToStore);\r\n\t\t\t\t})) ?? newValue;\r\n\t\t}\r\n\r\n\t\tif (api.processVariants) {\r\n\t\t\t// The a property values resolver resolves one value, we need to gather the persisted inner values first, and store them here:\r\n\t\t\tconst persistedVariantsHolder: Array<Array<UmbVariantDataModel>> = [];\r\n\r\n\t\t\tif (persistedValue) {\r\n\t\t\t\tawait api.processVariants(persistedValue, async (values) => {\r\n\t\t\t\t\tpersistedVariantsHolder.push(values as unknown as Array<UmbVariantDataModel>);\r\n\t\t\t\t\treturn undefined;\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\tlet valuesIndex = 0;\r\n\t\t\tnewValue =\r\n\t\t\t\t(await api.processVariants(newValue, async (values) => {\r\n\t\t\t\t\t// got some values (content and/or settings):\r\n\t\t\t\t\t// but how to get the persisted and the draft of this.....\r\n\t\t\t\t\tconst persistedVariants = persistedVariantsHolder[valuesIndex++];\r\n\r\n\t\t\t\t\treturn await this.#processVariants(\r\n\t\t\t\t\t\tpersistedVariants,\r\n\t\t\t\t\t\tvalues,\r\n\t\t\t\t\t\tvariantsToStore,\r\n\t\t\t\t\t\tapi.compareVariants ?? defaultCompareVariantMethod,\r\n\t\t\t\t\t);\r\n\t\t\t\t})) ?? newValue;\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\tif (api.ensureVariants) {\r\n\t\t\t// The a property values resolver resolves one value, we need to gather the persisted inner values first, and store them here:\r\n\t\t\t//const persistedVariants = newValue ? ((await api.readVariants(newValue)) ?? []) : [];\r\n\r\n\t\t\t// TODO: An expose for a Block should be invariant if the Block Content Element Type is not vary by culture.\r\n\t\t\t// TODO: And expose determination should look for invariant expose in this case.\r\n\t\t\tconst args = {\r\n\t\t\t\tselectedVariants,\r\n\t\t\t};\r\n\t\t\tnewValue = await api.ensureVariants(newValue, args);\r\n\t\t}\r\n\t\t\t*/\r\n\r\n\t\t// the api did not provide a value processor, so we will return the draftValue:\r\n\t\treturn newValue;\r\n\t}\r\n\r\n\t/**\r\n\t * Construct variants property of model.\r\n\t * @param {Array<UmbVariantDataModel> | undefined} persistedVariants - The persisted value.\r\n\t * @param {Array<UmbVariantDataModel>} draftVariants - The draft value.\r\n\t * @param {Array<UmbVariantId>} variantsToStore - The variants to be stored.\r\n\t * @param {(UmbVariantDataModel, UmbVariantDataModel) => boolean} compare - The compare method, which compares the unique properties of the variants.\r\n\t * @returns {UmbVariantDataModel[]} A new array of variants.\r\n\t */\r\n\t#processVariants<VariantModel extends UmbVariantDataModel = UmbVariantDataModel>(\r\n\t\tpersistedVariants: Array<VariantModel> | undefined,\r\n\t\tdraftVariants: Array<VariantModel>,\r\n\t\tvariantsToStore: Array<UmbVariantId>,\r\n\t\tcompare: (a: VariantModel, b: VariantModel) => boolean,\r\n\t): Array<VariantModel> {\r\n\t\tconst uniqueVariants = [...(persistedVariants ?? []), ...(draftVariants ?? [])].filter(\r\n\t\t\t(n, i, self) => i === self.findIndex((v) => compare(v, n)),\r\n\t\t);\r\n\r\n\t\treturn uniqueVariants\r\n\t\t\t.map((value) => {\r\n\t\t\t\tconst persistedVariant = persistedVariants?.find((x) => compare(x, value));\r\n\r\n\t\t\t\t// Should this value be saved?\r\n\t\t\t\tif (variantsToStore.some((x) => x.compare(value))) {\r\n\t\t\t\t\tconst draftVariant = draftVariants?.find((x) => compare(x, value));\r\n\r\n\t\t\t\t\treturn draftVariant;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// TODO: Check if this promise is needed: [NL]\r\n\t\t\t\t\treturn persistedVariant;\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\t.filter((x) => x !== undefined) as Array<VariantModel>;\r\n\r\n\t\t/*\r\n\t\treturn draftVariants\r\n\t\t\t.map((variant) => {\r\n\t\t\t\t// Should this variant be saved?\r\n\t\t\t\tif (variantsToStore.some((x) => x.compare(variant))) {\r\n\t\t\t\t\treturn variant;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// If not, then we will tru to find the variant in the persisted data and use that instead.\r\n\t\t\t\t\treturn persistedVariants?.find((x) => x.culture === variant.culture && x.segment === variant.segment);\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\t.filter((x) => x !== undefined) as Array<VariantModel>;\r\n\t\t\t*/\r\n\t}\r\n}\r\n","import { UmbMergeContentVariantDataController } from '../controller/merge-content-variant-data.controller.js';\r\nimport type { UmbElementDetailModel } from '../types.js';\r\nimport { UmbVariantId, umbVariantObjectCompare } from '@umbraco-cms/backoffice/variant';\r\nimport { UmbEntityWorkspaceDataManager, type UmbWorkspaceDataManager } from '@umbraco-cms/backoffice/workspace';\r\n\r\nfunction valueObjectCompare(a: any, b: any) {\r\n\treturn a.alias === b.alias && umbVariantObjectCompare(a, b);\r\n}\r\n\r\nexport class UmbElementWorkspaceDataManager<ModelType extends UmbElementDetailModel>\r\n\textends UmbEntityWorkspaceDataManager<ModelType>\r\n\timplements UmbWorkspaceDataManager<ModelType>\r\n{\r\n\tprotected _varies?: boolean;\r\n\t//#variesByCulture?: boolean;\r\n\t//#variesBySegment?: boolean;\r\n\r\n\tprotected override _sortCurrentData<GivenType extends Partial<ModelType> = Partial<ModelType>>(\r\n\t\tpersistedData: Partial<ModelType>,\r\n\t\tcurrentData: GivenType,\r\n\t): GivenType {\r\n\t\tcurrentData = super._sortCurrentData(persistedData, currentData);\r\n\t\t// Sort the values in the same order as the persisted data:\r\n\t\tconst persistedValues = persistedData.values;\r\n\t\tif (persistedValues && currentData.values) {\r\n\t\t\treturn {\r\n\t\t\t\t...currentData,\r\n\t\t\t\tvalues: [...currentData.values].sort(function (a, b) {\r\n\t\t\t\t\treturn (\r\n\t\t\t\t\t\tpersistedValues.findIndex((x) => valueObjectCompare(x, a)) -\r\n\t\t\t\t\t\tpersistedValues.findIndex((x) => valueObjectCompare(x, b))\r\n\t\t\t\t\t);\r\n\t\t\t\t}),\r\n\t\t\t};\r\n\t\t}\r\n\t\treturn currentData;\r\n\t}\r\n\r\n\t#updateLock = 0;\r\n\tinitiatePropertyValueChange() {\r\n\t\tthis.#updateLock++;\r\n\t\tthis._current.mute();\r\n\t\t// TODO: When ready enable this code will enable handling a finish automatically by this implementation 'using myState.initiatePropertyValueChange()' (Relies on TS support of Using) [NL]\r\n\t\t/*return {\r\n\t\t\t[Symbol.dispose]: this.finishPropertyValueChange,\r\n\t\t};*/\r\n\t}\r\n\tfinishPropertyValueChange = () => {\r\n\t\tthis.#updateLock--;\r\n\t\tthis.#triggerPropertyValueChanges();\r\n\t};\r\n\t#triggerPropertyValueChanges() {\r\n\t\tif (this.#updateLock === 0) {\r\n\t\t\tthis._current.unmute();\r\n\t\t}\r\n\t}\r\n\r\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n\tsetVariesByCulture(vary: boolean | undefined) {\r\n\t\t//this.#variesByCulture = vary;\r\n\t}\r\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n\tsetVariesBySegment(vary: boolean | undefined) {\r\n\t\t//this.#variesBySegment = vary;\r\n\t}\r\n\tsetVaries(vary: boolean | undefined) {\r\n\t\tthis._varies = vary;\r\n\t}\r\n\r\n\tasync constructData(selectedVariants: Array<UmbVariantId>): Promise<ModelType> {\r\n\t\t// Lets correct the selected variants, so invariant is included, or the only one if invariant.\r\n\t\t// TODO: VDIVD: Could a document be set to invariant but hold variant data inside it?\r\n\t\tconst invariantVariantId = UmbVariantId.CreateInvariant();\r\n\t\tlet variantsToStore = [invariantVariantId];\r\n\t\tif (this._varies === false) {\r\n\t\t\t// If we do not vary, we wil just pick the invariant variant id.\r\n\t\t\tselectedVariants = [invariantVariantId];\r\n\t\t} else {\r\n\t\t\tvariantsToStore = [...selectedVariants, invariantVariantId];\r\n\t\t}\r\n\r\n\t\tconst data = this.getCurrent();\r\n\t\tif (!data) throw new Error('Current data is missing');\r\n\t\t//if (!data.unique) throw new Error('Unique of current data is missing');\r\n\r\n\t\tconst persistedData = this.getPersisted();\r\n\r\n\t\treturn await new UmbMergeContentVariantDataController(this).process(\r\n\t\t\tpersistedData,\r\n\t\t\tdata,\r\n\t\t\tselectedVariants,\r\n\t\t\tvariantsToStore,\r\n\t\t);\r\n\t}\r\n}\r\n","import type { UmbContentDetailModel } from '../types.js';\r\nimport { UmbElementWorkspaceDataManager } from './element-data-manager.js';\r\nimport type { UmbControllerHost } from '@umbraco-cms/backoffice/controller-api';\r\nimport { appendToFrozenArray, jsonStringComparison } from '@umbraco-cms/backoffice/observable-api';\r\nimport { UmbVariantId, umbVariantObjectCompare, type UmbEntityVariantModel } from '@umbraco-cms/backoffice/variant';\r\n\r\nexport class UmbContentWorkspaceDataManager<\r\n\tModelType extends UmbContentDetailModel,\r\n\tModelVariantType extends UmbEntityVariantModel = ModelType extends { variants: UmbEntityVariantModel[] }\r\n\t\t? ModelType['variants'][0]\r\n\t\t: never,\r\n> extends UmbElementWorkspaceDataManager<ModelType> {\r\n\t//\r\n\t//#repository;\r\n\t#variantScaffold?: ModelVariantType;\r\n\r\n\tconstructor(host: UmbControllerHost, variantScaffold?: ModelVariantType) {\r\n\t\tsuper(host);\r\n\t\tthis.#variantScaffold = variantScaffold;\r\n\t}\r\n\r\n\tprotected override _sortCurrentData<GivenType extends Partial<ModelType> = Partial<ModelType>>(\r\n\t\tpersistedData: Partial<ModelType>,\r\n\t\tcurrentData: GivenType,\r\n\t): GivenType {\r\n\t\tcurrentData = super._sortCurrentData(persistedData, currentData);\r\n\t\t// Sort the variants in the same order as the persisted data:\r\n\t\tconst persistedVariants = persistedData.variants;\r\n\t\tif (persistedVariants && currentData.variants) {\r\n\t\t\treturn {\r\n\t\t\t\t...currentData,\r\n\t\t\t\tvariants: [...currentData.variants].sort(function (a, b) {\r\n\t\t\t\t\treturn (\r\n\t\t\t\t\t\tpersistedVariants.findIndex((x) => umbVariantObjectCompare(x, a)) -\r\n\t\t\t\t\t\tpersistedVariants.findIndex((x) => umbVariantObjectCompare(x, b))\r\n\t\t\t\t\t);\r\n\t\t\t\t}),\r\n\t\t\t};\r\n\t\t}\r\n\t\treturn currentData;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the variant scaffold data\r\n\t * @param {ModelVariantType} variantScaffold The variant scaffold data\r\n\t * @memberof UmbContentWorkspaceDataManager\r\n\t */\r\n\tsetVariantScaffold(variantScaffold: ModelVariantType) {\r\n\t\tthis.#variantScaffold = variantScaffold;\r\n\t}\r\n\r\n\tensureVariantData(variantId: UmbVariantId) {\r\n\t\tthis.updateVariantData(variantId);\r\n\t}\r\n\r\n\tupdateVariantData(variantId: UmbVariantId, update?: Partial<ModelVariantType>) {\r\n\t\tconst currentData = this.getCurrent();\r\n\t\tif (!currentData) throw new Error('Data is missing');\r\n\t\tif (!this.#variantScaffold) throw new Error('Variant scaffold data is missing');\r\n\t\tif (this._varies === true) {\r\n\t\t\t// If variant Id is invariant, we don't to have the variant appended to our data.\r\n\t\t\tif (variantId.isInvariant()) return;\r\n\t\t\tconst variant = currentData.variants.find((x) => variantId.compare(x));\r\n\t\t\tconst newVariants = appendToFrozenArray(\r\n\t\t\t\tcurrentData.variants,\r\n\t\t\t\t{\r\n\t\t\t\t\t...this.#variantScaffold,\r\n\t\t\t\t\t...variantId.toObject(),\r\n\t\t\t\t\t...variant,\r\n\t\t\t\t\t...update,\r\n\t\t\t\t} as ModelVariantType,\r\n\t\t\t\t(x) => variantId.compare(x),\r\n\t\t\t) as Array<ModelVariantType>;\r\n\t\t\tthis.updateCurrent({ variants: newVariants } as unknown as ModelType);\r\n\t\t} else if (this._varies === false) {\r\n\t\t\t// TODO: Beware about segments, in this case we need to also consider segments, if its allowed to vary by segments.\r\n\t\t\tconst invariantVariantId = UmbVariantId.CreateInvariant();\r\n\t\t\tconst variant = currentData.variants.find((x) => invariantVariantId.compare(x));\r\n\t\t\t// Cause we are invariant, we will just overwrite all variants with this one:\r\n\t\t\tconst newVariants = [\r\n\t\t\t\t{\r\n\t\t\t\t\t...this.#variantScaffold,\r\n\t\t\t\t\t...invariantVariantId.toObject(),\r\n\t\t\t\t\t...variant,\r\n\t\t\t\t\t...update,\r\n\t\t\t\t} as ModelVariantType,\r\n\t\t\t];\r\n\t\t\tthis.updateCurrent({ variants: newVariants } as unknown as ModelType);\r\n\t\t} else {\r\n\t\t\tthrow new Error('Varies by culture is missing');\r\n\t\t}\r\n\t}\r\n\r\n\tgetChangedVariants() {\r\n\t\tconst persisted = this.getPersisted();\r\n\t\tconst current = this.getCurrent();\r\n\t\tif (!current) throw new Error('Current data is missing');\r\n\r\n\t\tconst changedVariants = current?.variants.map((variant) => {\r\n\t\t\tconst persistedVariant = persisted?.variants.find((x) => UmbVariantId.Create(variant).compare(x));\r\n\t\t\treturn {\r\n\t\t\t\tculture: variant.culture,\r\n\t\t\t\tsegment: variant.segment,\r\n\t\t\t\tequal: persistedVariant ? jsonStringComparison(variant, persistedVariant) : false,\r\n\t\t\t};\r\n\t\t});\r\n\r\n\t\tconst changedProperties = current?.values.map((value) => {\r\n\t\t\tconst persistedValues = persisted?.values.find((x) => UmbVariantId.Create(value).compare(x));\r\n\t\t\treturn {\r\n\t\t\t\tculture: value.culture,\r\n\t\t\t\tsegment: value.segment,\r\n\t\t\t\tequal: persistedValues ? jsonStringComparison(value, persistedValues) : false,\r\n\t\t\t};\r\n\t\t});\r\n\r\n\t\t// calculate the variantIds of those who either have a change in properties or in variants:\r\n\t\treturn (\r\n\t\t\tchangedVariants\r\n\t\t\t\t?.concat(changedProperties ?? [])\r\n\t\t\t\t.filter((x) => x.equal === false)\r\n\t\t\t\t.map((x) => new UmbVariantId(x.culture, x.segment)) ?? []\r\n\t\t);\r\n\t}\r\n}\r\n","import type { UmbContentPropertyDatasetContext } from './content-property-dataset.context.js';\r\nimport type { UmbPropertyDatasetContext } from '@umbraco-cms/backoffice/property';\r\nimport { UmbContextToken } from '@umbraco-cms/backoffice/context-api';\r\n\r\nexport const IsContentPropertyDatasetContext = (\r\n\tcontext: UmbPropertyDatasetContext,\r\n): context is UmbContentPropertyDatasetContext => (context as any).IS_CONTENT === true;\r\n\r\nexport const UMB_CONTENT_PROPERTY_DATASET_CONTEXT = new UmbContextToken<\r\n\tUmbPropertyDatasetContext,\r\n\tUmbContentPropertyDatasetContext\r\n>('UmbPropertyDatasetContext', undefined, IsContentPropertyDatasetContext);\r\n","import type { UmbElementDetailModel } from '../types.js';\r\nimport type { UmbElementPropertyDataOwner } from './element-property-data-owner.interface.js';\r\nimport type { UmbPropertyDatasetContext } from '@umbraco-cms/backoffice/property';\r\nimport { UMB_PROPERTY_DATASET_CONTEXT } from '@umbraco-cms/backoffice/property';\r\nimport type { UmbControllerHost } from '@umbraco-cms/backoffice/controller-api';\r\nimport { UmbContextBase } from '@umbraco-cms/backoffice/class-api';\r\nimport type { Observable } from '@umbraco-cms/backoffice/external/rxjs';\r\nimport {\r\n\tUmbBasicState,\r\n\tUmbBooleanState,\r\n\tclassEqualMemoization,\r\n\tcreateObservablePart,\r\n\tmergeObservables,\r\n} from '@umbraco-cms/backoffice/observable-api';\r\nimport { UmbVariantId } from '@umbraco-cms/backoffice/variant';\r\nimport type { UmbContentTypeModel, UmbPropertyTypeModel } from '@umbraco-cms/backoffice/content-type';\r\nimport type { UmbEntityUnique } from '@umbraco-cms/backoffice/entity';\r\n\r\ntype UmbPropertyVariantIdMapType = Array<{ alias: string; variantId: UmbVariantId }>;\r\n\r\nexport abstract class UmbElementPropertyDatasetContext<\r\n\t\tContentModel extends UmbElementDetailModel = UmbElementDetailModel,\r\n\t\tContentTypeModel extends UmbContentTypeModel = UmbContentTypeModel,\r\n\t\tDataOwnerType extends UmbElementPropertyDataOwner<ContentModel, ContentTypeModel> = UmbElementPropertyDataOwner<\r\n\t\t\tContentModel,\r\n\t\t\tContentTypeModel\r\n\t\t>,\r\n\t>\r\n\textends UmbContextBase<UmbPropertyDatasetContext>\r\n\timplements UmbPropertyDatasetContext\r\n{\r\n\tprotected readonly _dataOwner: DataOwnerType;\r\n\t#variantId: UmbVariantId;\r\n\tpublic getVariantId() {\r\n\t\treturn this.#variantId;\r\n\t}\r\n\r\n\tabstract name: Observable<string | undefined>;\r\n\tabstract culture: Observable<string | null | undefined>;\r\n\tabstract segment: Observable<string | null | undefined>;\r\n\r\n\t#propertyVariantIdPromise?: Promise<never>;\r\n\t#propertyVariantIdPromiseResolver?: () => void;\r\n\t#propertyVariantIdMap = new UmbBasicState<UmbPropertyVariantIdMapType>([]);\r\n\tprivate readonly _propertyVariantIdMap = this.#propertyVariantIdMap.asObservable();\r\n\r\n\t#readOnly = new UmbBooleanState(false);\r\n\tpublic readOnly = this.#readOnly.asObservable();\r\n\r\n\tgetEntityType(): string {\r\n\t\treturn this._dataOwner.getEntityType();\r\n\t}\r\n\tgetUnique(): UmbEntityUnique | undefined {\r\n\t\treturn this._dataOwner.getUnique();\r\n\t}\r\n\tabstract getName(): string | undefined;\r\n\r\n\tgetReadOnly() {\r\n\t\treturn this.#readOnly.getValue();\r\n\t}\r\n\r\n\tconstructor(host: UmbControllerHost, dataOwner: DataOwnerType, variantId?: UmbVariantId) {\r\n\t\t// The controller alias, is a very generic name cause we want only one of these for this controller host.\r\n\t\tsuper(host, UMB_PROPERTY_DATASET_CONTEXT);\r\n\t\tthis._dataOwner = dataOwner;\r\n\t\tthis.#variantId = variantId ?? UmbVariantId.CreateInvariant();\r\n\r\n\t\tthis.#propertyVariantIdPromise = new Promise((resolve) => {\r\n\t\t\tthis.#propertyVariantIdPromiseResolver = resolve as any;\r\n\t\t});\r\n\r\n\t\tthis.observe(\r\n\t\t\tthis._dataOwner.readOnlyState.states,\r\n\t\t\t(states) => {\r\n\t\t\t\tconst isReadOnly = states.some((state) => state.variantId.equal(this.#variantId));\r\n\t\t\t\tthis.#readOnly.setValue(isReadOnly);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\t\t);\r\n\r\n\t\t// TODO: Refactor this into a separate manager/controller of some sort? [NL]\r\n\t\tthis.observe(\r\n\t\t\tthis._dataOwner.structure.contentTypeProperties,\r\n\t\t\t(props: UmbPropertyTypeModel[]) => {\r\n\t\t\t\tconst map = props.map((prop) => ({ alias: prop.alias, variantId: this.#createPropertyVariantId(prop) }));\r\n\t\t\t\tthis.#propertyVariantIdMap.setValue(map);\r\n\t\t\t\t// Resolve promise, to let the once waiting on this know.\r\n\t\t\t\tif (this.#propertyVariantIdPromiseResolver) {\r\n\t\t\t\t\tthis.#propertyVariantIdPromiseResolver();\r\n\t\t\t\t\tthis.#propertyVariantIdPromiseResolver = undefined;\r\n\t\t\t\t\tthis.#propertyVariantIdPromise = undefined;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tnull,\r\n\t\t);\r\n\t}\r\n\r\n\t#createPropertyVariantId(property: UmbPropertyTypeModel) {\r\n\t\treturn UmbVariantId.Create({\r\n\t\t\tculture: property.variesByCulture ? this.#variantId.culture : null,\r\n\t\t\tsegment: property.variesBySegment ? this.#variantId.segment : null,\r\n\t\t});\r\n\t}\r\n\r\n\t#propertiesObservable?: Observable<ContentModel['values']>;\r\n\t// Should it be possible to get the properties as a list of property aliases?\r\n\tget properties(): Observable<ContentModel['values']> {\r\n\t\tif (!this.#propertiesObservable) {\r\n\t\t\tthis.#propertiesObservable = mergeObservables(\r\n\t\t\t\t[this._propertyVariantIdMap, this._dataOwner.values],\r\n\t\t\t\tthis.#mergeVariantIdsAndValues,\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn this.#propertiesObservable;\r\n\t}\r\n\r\n\t#mergeVariantIdsAndValues([props, values]: [UmbPropertyVariantIdMapType, ContentModel['values'] | undefined]) {\r\n\t\tconst r: ContentModel['values'] = [];\r\n\t\tif (values) {\r\n\t\t\tfor (const prop of props) {\r\n\t\t\t\tconst f = values.find((v) => prop.alias === v.alias && prop.variantId.compare(v));\r\n\t\t\t\tif (f) {\r\n\t\t\t\t\tr.push(f);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn r as ContentModel['values'];\r\n\t}\r\n\r\n\tasync getProperties(): Promise<ContentModel['values']> {\r\n\t\tawait this.#propertyVariantIdPromise;\r\n\t\treturn this.#mergeVariantIdsAndValues([\r\n\t\t\tthis.#propertyVariantIdMap.getValue(),\r\n\t\t\tthis._dataOwner.getValues(),\r\n\t\t]) as ContentModel['values'];\r\n\t}\r\n\r\n\t/**\r\n\t * @function propertyVariantId\r\n\t * @param {string} propertyAlias - The property alias to observe the variantId of.\r\n\t * @returns {Promise<Observable<UmbVariantId | undefined> | undefined>} - The observable for this properties variantId.\r\n\t * @description Get an Observable for the variant id of this property.\r\n\t */\r\n\tasync propertyVariantId(propertyAlias: string) {\r\n\t\t/*\r\n\t\treturn (await this.#workspace.structure.propertyStructureByAlias(propertyAlias)).pipe(\r\n\t\t\tmap((property) => (property ? this.#createPropertyVariantId(property) : undefined)),\r\n\t\t);\r\n\t\t*/\r\n\t\treturn createObservablePart(\r\n\t\t\tthis._propertyVariantIdMap,\r\n\t\t\t(x) => x.find((v) => v.alias === propertyAlias)?.variantId,\r\n\t\t\tclassEqualMemoization,\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * @function propertyValueByAlias\r\n\t * @param {string} propertyAlias  The alias of the property\r\n\t * @returns {Promise<Observable<ReturnType | undefined> | undefined>} - An observable of the property value\r\n\t * @description Get an Observable for the value of this property.\r\n\t */\r\n\tasync propertyValueByAlias<ReturnType = unknown>(\r\n\t\tpropertyAlias: string,\r\n\t): Promise<Observable<ReturnType | undefined> | undefined> {\r\n\t\tawait this._dataOwner.isLoaded();\r\n\t\tawait this.#propertyVariantIdPromise;\r\n\t\treturn mergeObservables(\r\n\t\t\t[await this.propertyVariantId(propertyAlias), this._dataOwner.values],\r\n\t\t\t([variantId, values]) => {\r\n\t\t\t\treturn variantId\r\n\t\t\t\t\t? (values?.find((x) => x?.alias === propertyAlias && variantId.compare(x))?.value as ReturnType)\r\n\t\t\t\t\t: undefined;\r\n\t\t\t},\r\n\t\t);\r\n\t}\r\n\r\n\t// TODO: Refactor: Not used currently, but should investigate if we can implement this, to spare some energy.\r\n\tasync propertyValueByAliasAndVariantId<ReturnType = unknown>(\r\n\t\tpropertyAlias: string,\r\n\t\tpropertyVariantId: UmbVariantId,\r\n\t): Promise<Observable<ReturnType | undefined> | undefined> {\r\n\t\treturn this._dataOwner.propertyValueByAlias<ReturnType>(propertyAlias, propertyVariantId);\r\n\t}\r\n\r\n\t/**\r\n\t * @function setPropertyValueByVariant\r\n\t * @param {string} propertyAlias - The alias of the property\r\n\t * @param {unknown} value - value can be a promise resolving into the actual value or the raw value it self.\r\n\t * @param {UmbVariantId} propertyVariantId - The variant id for the value to be set for.\r\n\t * @returns {Promise<unknown>} - A promise that resolves once the value has been set.\r\n\t * @description Get the value of this property.\r\n\t */\r\n\tsetPropertyValueByVariant(propertyAlias: string, value: unknown, propertyVariantId: UmbVariantId): Promise<void> {\r\n\t\treturn this._dataOwner.setPropertyValue(propertyAlias, value, propertyVariantId);\r\n\t}\r\n\r\n\t/**\r\n\t * @function setPropertyValue\r\n\t * @param {string} propertyAlias - The alias for the value to be set\r\n\t * @param {PromiseLike<unknown>} value - value can be a promise resolving into the actual value or the raw value it self.\r\n\t * @returns {Promise<void>}\r\n\t * @description Set the value of this property.\r\n\t */\r\n\tasync setPropertyValue(propertyAlias: string, value: PromiseLike<unknown>) {\r\n\t\tthis._dataOwner.initiatePropertyValueChange();\r\n\t\tawait this.#propertyVariantIdPromise;\r\n\t\tconst propVariantId = this.#propertyVariantIdMap.getValue().find((x) => x.alias === propertyAlias)?.variantId;\r\n\t\tif (propVariantId) {\r\n\t\t\tawait this._dataOwner.setPropertyValue(propertyAlias, await value, propVariantId);\r\n\t\t}\r\n\t\tthis._dataOwner.finishPropertyValueChange();\r\n\t}\r\n\r\n\toverride destroy() {\r\n\t\tsuper.destroy();\r\n\t\tthis.#propertyVariantIdMap?.destroy();\r\n\t\t(this.#propertyVariantIdMap as unknown) = undefined;\r\n\t}\r\n}\r\n","import type { UmbContentWorkspaceContext } from '../workspace/index.js';\r\nimport type { UmbContentDetailModel } from '../types.js';\r\nimport { UmbElementPropertyDatasetContext } from './element-property-dataset.context.js';\r\nimport type { UmbControllerHost } from '@umbraco-cms/backoffice/controller-api';\r\nimport { UmbObjectState } from '@umbraco-cms/backoffice/observable-api';\r\nimport type { UmbEntityVariantModel, UmbVariantId } from '@umbraco-cms/backoffice/variant';\r\nimport type { UmbContentTypeModel } from '@umbraco-cms/backoffice/content-type';\r\nimport { UmbRoutePathAddendumContext } from '@umbraco-cms/backoffice/router';\r\n\r\nexport class UmbContentPropertyDatasetContext<\r\n\tContentModel extends UmbContentDetailModel = UmbContentDetailModel,\r\n\tContentTypeModel extends UmbContentTypeModel = UmbContentTypeModel,\r\n\tVariantModelType extends UmbEntityVariantModel = UmbEntityVariantModel,\r\n> extends UmbElementPropertyDatasetContext<\r\n\tContentModel,\r\n\tContentTypeModel,\r\n\tUmbContentWorkspaceContext<ContentModel, ContentTypeModel, VariantModelType>\r\n> {\r\n\t//\r\n\t#pathAddendum = new UmbRoutePathAddendumContext(this);\r\n\t#currentVariant = new UmbObjectState<VariantModelType | undefined>(undefined);\r\n\tcurrentVariant = this.#currentVariant.asObservable();\r\n\r\n\tname = this.#currentVariant.asObservablePart((x) => x?.name);\r\n\tculture = this.#currentVariant.asObservablePart((x) => x?.culture);\r\n\tsegment = this.#currentVariant.asObservablePart((x) => x?.segment);\r\n\r\n\treadonly IS_CONTENT = true;\r\n\r\n\tgetName(): string | undefined {\r\n\t\treturn this._dataOwner.getName(this.getVariantId());\r\n\t}\r\n\tsetName(name: string) {\r\n\t\tthis._dataOwner.setName(name, this.getVariantId());\r\n\t}\r\n\t/**\r\n\t * @deprecated Its not clear why we have this. We should either document the need better or get rid of it.\r\n\t * @returns {UmbEntityVariantModel | undefined} - gives information about the current variant.\r\n\t */\r\n\tgetVariantInfo() {\r\n\t\treturn this._dataOwner.getVariant(this.getVariantId());\r\n\t}\r\n\r\n\tconstructor(\r\n\t\thost: UmbControllerHost,\r\n\t\tdataOwner: UmbContentWorkspaceContext<ContentModel, ContentTypeModel, VariantModelType>,\r\n\t\tvariantId?: UmbVariantId,\r\n\t) {\r\n\t\t// The controller alias, is a very generic name cause we want only one of these for this controller host.\r\n\t\tsuper(host, dataOwner, variantId);\r\n\r\n\t\tthis.#pathAddendum.setAddendum(variantId ? variantId.toString() : '');\r\n\r\n\t\tthis.observe(\r\n\t\t\tthis._dataOwner.variantById(this.getVariantId()),\r\n\t\t\tasync (variantInfo) => {\r\n\t\t\t\tif (!variantInfo) return;\r\n\t\t\t\tthis.#currentVariant.setValue(variantInfo);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\t\t);\r\n\t}\r\n}\r\n","import type { UmbContentDetailModel, UmbElementValueModel } from '../types.js';\r\nimport { UmbContentWorkspaceDataManager } from '../manager/index.js';\r\nimport { UmbMergeContentVariantDataController } from '../controller/merge-content-variant-data.controller.js';\r\nimport type { UmbContentVariantPickerData, UmbContentVariantPickerValue } from '../variant-picker/index.js';\r\nimport type { UmbContentPropertyDatasetContext } from '../property-dataset-context/index.js';\r\nimport type { UmbContentValidationRepository } from '../repository/content-validation-repository.interface.js';\r\nimport type { UmbContentWorkspaceContext } from './content-workspace-context.interface.js';\r\nimport type { UmbControllerHost } from '@umbraco-cms/backoffice/controller-api';\r\nimport type { UmbDetailRepository, UmbDetailRepositoryConstructor } from '@umbraco-cms/backoffice/repository';\r\nimport {\r\n\tUmbEntityDetailWorkspaceContextBase,\r\n\tUmbWorkspaceSplitViewManager,\r\n\ttype UmbEntityDetailWorkspaceContextArgs,\r\n\ttype UmbEntityDetailWorkspaceContextCreateArgs,\r\n} from '@umbraco-cms/backoffice/workspace';\r\nimport {\r\n\tUmbContentTypeStructureManager,\r\n\ttype UmbContentTypeModel,\r\n\ttype UmbPropertyTypeModel,\r\n} from '@umbraco-cms/backoffice/content-type';\r\nimport {\r\n\tUMB_INVARIANT_CULTURE,\r\n\tUmbVariantId,\r\n\ttype UmbEntityVariantModel,\r\n\ttype UmbEntityVariantOptionModel,\r\n} from '@umbraco-cms/backoffice/variant';\r\nimport { UmbDeprecation, UmbReadOnlyVariantStateManager } from '@umbraco-cms/backoffice/utils';\r\nimport { UmbDataTypeDetailRepository, UmbDataTypeItemRepositoryManager } from '@umbraco-cms/backoffice/data-type';\r\nimport { appendToFrozenArray, mergeObservables, UmbArrayState } from '@umbraco-cms/backoffice/observable-api';\r\nimport { UmbLanguageCollectionRepository, type UmbLanguageDetailModel } from '@umbraco-cms/backoffice/language';\r\nimport type { Observable } from '@umbraco-cms/backoffice/external/rxjs';\r\nimport { firstValueFrom } from '@umbraco-cms/backoffice/external/rxjs';\r\nimport {\r\n\tUMB_VALIDATION_CONTEXT,\r\n\tUMB_VALIDATION_EMPTY_LOCALIZATION_KEY,\r\n\tUmbDataPathVariantQuery,\r\n\tUmbServerModelValidatorContext,\r\n\tUmbVariantsValidationPathTranslator,\r\n\tUmbVariantValuesValidationPathTranslator,\r\n} from '@umbraco-cms/backoffice/validation';\r\nimport type { UmbModalToken } from '@umbraco-cms/backoffice/modal';\r\nimport { UMB_MODAL_MANAGER_CONTEXT } from '@umbraco-cms/backoffice/modal';\r\nimport { UMB_ACTION_EVENT_CONTEXT } from '@umbraco-cms/backoffice/action';\r\nimport {\r\n\tUmbEntityUpdatedEvent,\r\n\tUmbRequestReloadChildrenOfEntityEvent,\r\n\tUmbRequestReloadStructureForEntityEvent,\r\n} from '@umbraco-cms/backoffice/entity-action';\r\nimport type { ClassConstructor } from '@umbraco-cms/backoffice/extension-api';\r\nimport {\r\n\tUmbPropertyValuePresetVariantBuilderController,\r\n\ttype UmbPropertyTypePresetModel,\r\n\ttype UmbPropertyTypePresetModelTypeModel,\r\n} from '@umbraco-cms/backoffice/property';\r\n\r\nexport interface UmbContentDetailWorkspaceContextArgs<\r\n\tDetailModelType extends UmbContentDetailModel<VariantModelType>,\r\n\tContentTypeDetailModelType extends UmbContentTypeModel = UmbContentTypeModel,\r\n\tVariantModelType extends UmbEntityVariantModel = DetailModelType extends { variants: UmbEntityVariantModel[] }\r\n\t\t? DetailModelType['variants'][0]\r\n\t\t: never,\r\n\tVariantOptionModelType extends UmbEntityVariantOptionModel = UmbEntityVariantOptionModel<VariantModelType>,\r\n> extends UmbEntityDetailWorkspaceContextArgs {\r\n\tcontentTypeDetailRepository: UmbDetailRepositoryConstructor<ContentTypeDetailModelType>;\r\n\tcontentValidationRepository?: ClassConstructor<UmbContentValidationRepository<DetailModelType>>;\r\n\tskipValidationOnSubmit?: boolean;\r\n\tcontentVariantScaffold: VariantModelType;\r\n\tcontentTypePropertyName: string;\r\n\tsaveModalToken?: UmbModalToken<UmbContentVariantPickerData<VariantOptionModelType>, UmbContentVariantPickerValue>;\r\n}\r\n\r\n/**\r\n * The base class for a content detail workspace context.\r\n * @exports\r\n * @abstract\r\n * @class UmbContentDetailWorkspaceContextBase\r\n * @augments {UmbEntityDetailWorkspaceContextBase<DetailModelType, DetailRepositoryType, CreateArgsType>}\r\n * @implements {UmbContentWorkspaceContext<DetailModelType, ContentTypeDetailModelType, VariantModelType>}\r\n * @template DetailModelType\r\n * @template DetailRepositoryType\r\n * @template ContentTypeDetailModelType\r\n * @template VariantModelType\r\n * @template VariantOptionModelType\r\n * @template CreateArgsType\r\n */\r\nexport abstract class UmbContentDetailWorkspaceContextBase<\r\n\t\tDetailModelType extends UmbContentDetailModel<VariantModelType>,\r\n\t\tDetailRepositoryType extends UmbDetailRepository<DetailModelType> = UmbDetailRepository<DetailModelType>,\r\n\t\tContentTypeDetailModelType extends UmbContentTypeModel = UmbContentTypeModel,\r\n\t\tVariantModelType extends UmbEntityVariantModel = DetailModelType extends { variants: UmbEntityVariantModel[] }\r\n\t\t\t? DetailModelType['variants'][0]\r\n\t\t\t: never,\r\n\t\tVariantOptionModelType extends UmbEntityVariantOptionModel = UmbEntityVariantOptionModel<VariantModelType>,\r\n\t\tCreateArgsType extends\r\n\t\t\tUmbEntityDetailWorkspaceContextCreateArgs<DetailModelType> = UmbEntityDetailWorkspaceContextCreateArgs<DetailModelType>,\r\n\t>\r\n\textends UmbEntityDetailWorkspaceContextBase<DetailModelType, DetailRepositoryType, CreateArgsType>\r\n\timplements UmbContentWorkspaceContext<DetailModelType, ContentTypeDetailModelType, VariantModelType>\r\n{\r\n\tpublic readonly IS_CONTENT_WORKSPACE_CONTEXT = true as const;\r\n\r\n\tpublic readonly readOnlyState = new UmbReadOnlyVariantStateManager(this);\r\n\r\n\t/* Content Data */\r\n\tprotected override readonly _data = new UmbContentWorkspaceDataManager<DetailModelType, VariantModelType>(this);\r\n\r\n\tpublic override readonly data = this._data.current;\r\n\tpublic readonly values = this._data.createObservablePartOfCurrent((data) => data?.values);\r\n\tpublic readonly variants = this._data.createObservablePartOfCurrent((data) => data?.variants ?? []);\r\n\tpublic override readonly persistedData = this._data.persisted;\r\n\r\n\t/* Content Type (Structure) Data */\r\n\tpublic readonly structure;\r\n\tpublic readonly variesByCulture;\r\n\tpublic readonly variesBySegment;\r\n\tpublic readonly varies;\r\n\r\n\tabstract readonly contentTypeUnique: Observable<string | undefined>;\r\n\r\n\t/* Data Type */\r\n\t// This dataTypeItemManager is used to load the data type items for this content type, so we have all data-types for this content type up front. [NL]\r\n\t// But once we have a propert application cache this could be solved in a way where we ask the cache for the data type items. [NL]\r\n\t// And then we do not need to store them here in a local manager, but instead just request them here up-front and then again needed(which would get them from the cache, which as well could be update while this runs) [NL]\r\n\treadonly #dataTypeItemManager = new UmbDataTypeItemRepositoryManager(this);\r\n\r\n\t#varies?: boolean;\r\n\t#variesByCulture?: boolean;\r\n\t#variesBySegment?: boolean;\r\n\r\n\t/* Split View */\r\n\treadonly splitView = new UmbWorkspaceSplitViewManager();\r\n\r\n\t/* Variant Options */\r\n\t// TODO: Optimize this so it uses either a App Language Context? [NL]\r\n\t#languageRepository = new UmbLanguageCollectionRepository(this);\r\n\t#languages = new UmbArrayState<UmbLanguageDetailModel>([], (x) => x.unique);\r\n\t/**\r\n\t * @private\r\n\t * @description - Should not be used by external code.\r\n\t */\r\n\tpublic readonly languages = this.#languages.asObservable();\r\n\r\n\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n\t// @ts-ignore\r\n\t// TODO: fix type error\r\n\tpublic readonly variantOptions;\r\n\r\n\t#validateOnSubmit: boolean;\r\n\t#serverValidation = new UmbServerModelValidatorContext(this);\r\n\t#validationRepositoryClass?: ClassConstructor<UmbContentValidationRepository<DetailModelType>>;\r\n\t#validationRepository?: UmbContentValidationRepository<DetailModelType>;\r\n\r\n\t#saveModalToken?: UmbModalToken<UmbContentVariantPickerData<VariantOptionModelType>, UmbContentVariantPickerValue>;\r\n\t#contentTypePropertyName: string;\r\n\r\n\tconstructor(\r\n\t\thost: UmbControllerHost,\r\n\t\targs: UmbContentDetailWorkspaceContextArgs<\r\n\t\t\tDetailModelType,\r\n\t\t\tContentTypeDetailModelType,\r\n\t\t\tVariantModelType,\r\n\t\t\tVariantOptionModelType\r\n\t\t>,\r\n\t) {\r\n\t\tsuper(host, args);\r\n\r\n\t\tthis._data.setVariantScaffold(args.contentVariantScaffold);\r\n\t\tthis.#saveModalToken = args.saveModalToken;\r\n\t\tthis.#contentTypePropertyName = args.contentTypePropertyName;\r\n\r\n\t\tconst contentTypeDetailRepository = new args.contentTypeDetailRepository(this);\r\n\t\tthis.#validationRepositoryClass = args.contentValidationRepository;\r\n\t\tthis.#validateOnSubmit = args.skipValidationOnSubmit ? !args.skipValidationOnSubmit : true;\r\n\t\tthis.structure = new UmbContentTypeStructureManager<ContentTypeDetailModelType>(this, contentTypeDetailRepository);\r\n\t\tthis.variesByCulture = this.structure.ownerContentTypeObservablePart((x) => x?.variesByCulture);\r\n\t\tthis.variesBySegment = this.structure.ownerContentTypeObservablePart((x) => x?.variesBySegment);\r\n\t\tthis.varies = this.structure.ownerContentTypeObservablePart((x) =>\r\n\t\t\tx ? x.variesByCulture || x.variesBySegment : undefined,\r\n\t\t);\r\n\r\n\t\tthis.variantOptions = mergeObservables(\r\n\t\t\t[this.varies, this.variants, this.languages],\r\n\t\t\t([varies, variants, languages]) => {\r\n\t\t\t\t// TODO: When including segments, when be aware about the case of segment varying when not culture varying. [NL]\r\n\t\t\t\tif (varies === true) {\r\n\t\t\t\t\treturn languages.map((language) => {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tvariant: variants.find((x) => x.culture === language.unique),\r\n\t\t\t\t\t\t\tlanguage,\r\n\t\t\t\t\t\t\t// TODO: When including segments, this object should be updated to include a object for the segment. [NL]\r\n\t\t\t\t\t\t\t// TODO: When including segments, the unique should be updated to include the segment as well. [NL]\r\n\t\t\t\t\t\t\tunique: language.unique, // This must be a variantId string!\r\n\t\t\t\t\t\t\tculture: language.unique,\r\n\t\t\t\t\t\t\tsegment: null,\r\n\t\t\t\t\t\t} as VariantOptionModelType;\r\n\t\t\t\t\t});\r\n\t\t\t\t} else if (varies === false) {\r\n\t\t\t\t\treturn [\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvariant: variants.find((x) => x.culture === null),\r\n\t\t\t\t\t\t\tlanguage: languages.find((x) => x.isDefault),\r\n\t\t\t\t\t\t\tculture: null,\r\n\t\t\t\t\t\t\tsegment: null,\r\n\t\t\t\t\t\t\tunique: UMB_INVARIANT_CULTURE, // This must be a variantId string!\r\n\t\t\t\t\t\t} as VariantOptionModelType,\r\n\t\t\t\t\t];\r\n\t\t\t\t}\r\n\t\t\t\treturn [] as Array<VariantOptionModelType>;\r\n\t\t\t},\r\n\t\t);\r\n\r\n\t\tnew UmbVariantValuesValidationPathTranslator(this);\r\n\t\tnew UmbVariantsValidationPathTranslator(this);\r\n\r\n\t\tthis.observe(\r\n\t\t\tthis.varies,\r\n\t\t\t(varies) => {\r\n\t\t\t\tthis._data.setVaries(varies);\r\n\t\t\t\tthis.#varies = varies;\r\n\t\t\t},\r\n\t\t\tnull,\r\n\t\t);\r\n\t\tthis.observe(\r\n\t\t\tthis.variesByCulture,\r\n\t\t\t(varies) => {\r\n\t\t\t\tthis._data.setVariesByCulture(varies);\r\n\t\t\t\tthis.#variesByCulture = varies;\r\n\t\t\t},\r\n\t\t\tnull,\r\n\t\t);\r\n\t\tthis.observe(\r\n\t\t\tthis.variesBySegment,\r\n\t\t\t(varies) => {\r\n\t\t\t\tthis._data.setVariesBySegment(varies);\r\n\t\t\t\tthis.#variesBySegment = varies;\r\n\t\t\t},\r\n\t\t\tnull,\r\n\t\t);\r\n\t\tthis.observe(\r\n\t\t\tthis.structure.contentTypeDataTypeUniques,\r\n\t\t\t(dataTypeUniques: Array<string>) => {\r\n\t\t\t\tthis.#dataTypeItemManager.setUniques(dataTypeUniques);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\t\t);\r\n\r\n\t\tthis.loadLanguages();\r\n\t}\r\n\r\n\tpublic async loadLanguages() {\r\n\t\t// TODO: If we don't end up having a Global Context for languages, then we should at least change this into using a asObservable which should be returned from the repository. [Nl]\r\n\t\tconst { data } = await this.#languageRepository.requestCollection({});\r\n\t\tthis.#languages.setValue(data?.items ?? []);\r\n\t}\r\n\r\n\tprotected override async _scaffoldProcessData(data: DetailModelType): Promise<DetailModelType> {\r\n\t\t// Load the content type structure, usually this comes from the data, but in this case we are making the data, and we need this to be able to complete the data. [NL]\r\n\t\tawait this.structure.loadType((data as any)[this.#contentTypePropertyName].unique);\r\n\r\n\t\t// Set culture and segment for all values:\r\n\t\tconst cutlures = this.#languages.getValue().map((x) => x.unique);\r\n\r\n\t\tif (this.structure.variesBySegment) {\r\n\t\t\tconsole.warn('Segments are not yet implemented for preset');\r\n\t\t}\r\n\t\tconst segments: Array<string> | undefined = this.structure.variesBySegment ? [] : undefined;\r\n\r\n\t\tconst repo = new UmbDataTypeDetailRepository(this);\r\n\r\n\t\tconst propertyTypes = await this.structure.getContentTypeProperties();\r\n\t\tconst valueDefinitions = await Promise.all(\r\n\t\t\tpropertyTypes.map(async (property) => {\r\n\t\t\t\t// TODO: Implement caching for data-type requests. [NL]\r\n\t\t\t\tconst dataType = (await repo.requestByUnique(property.dataType.unique)).data;\r\n\t\t\t\t// This means if its not loaded this will never resolve and the error below will never happen.\r\n\t\t\t\tif (!dataType) {\r\n\t\t\t\t\tthrow new Error(`DataType of \"${property.dataType.unique}\" not found.`);\r\n\t\t\t\t}\r\n\t\t\t\tif (!dataType.editorUiAlias) {\r\n\t\t\t\t\tthrow new Error(`DataType of \"${property.dataType.unique}\" did not have a editorUiAlias.`);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn {\r\n\t\t\t\t\talias: property.alias,\r\n\t\t\t\t\tpropertyEditorUiAlias: dataType.editorUiAlias,\r\n\t\t\t\t\tpropertyEditorSchemaAlias: dataType.editorAlias,\r\n\t\t\t\t\tconfig: dataType.values,\r\n\t\t\t\t\ttypeArgs: {\r\n\t\t\t\t\t\tvariesByCulture: property.variesByCulture,\r\n\t\t\t\t\t\tvariesBySegment: property.variesBySegment,\r\n\t\t\t\t\t} as UmbPropertyTypePresetModelTypeModel,\r\n\t\t\t\t} as UmbPropertyTypePresetModel;\r\n\t\t\t}),\r\n\t\t);\r\n\r\n\t\tconst controller = new UmbPropertyValuePresetVariantBuilderController(this);\r\n\t\tcontroller.setCultures(cutlures);\r\n\t\tif (segments) {\r\n\t\t\tcontroller.setSegments(segments);\r\n\t\t}\r\n\t\tdata.values = await controller.create(valueDefinitions);\r\n\r\n\t\treturn data;\r\n\t}\r\n\r\n\t/**\r\n\t * Get the name of a variant\r\n\t * @param {UmbVariantId } [variantId] - The variant id\r\n\t * @returns { string | undefined} - The name of the variant\r\n\t * @memberof UmbContentDetailWorkspaceContextBase\r\n\t */\r\n\tpublic getName(variantId?: UmbVariantId): string | undefined {\r\n\t\tconst variants = this._data.getCurrent()?.variants;\r\n\t\tif (!variants) return;\r\n\t\tif (variantId) {\r\n\t\t\treturn variants.find((x) => variantId.compare(x))?.name;\r\n\t\t} else {\r\n\t\t\treturn variants[0]?.name;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Set the name of a variant\r\n\t * @param {string} name - The name of the variant\r\n\t * @param {UmbVariantId} [variantId] - The variant id\r\n\t * @memberof UmbContentDetailWorkspaceContextBase\r\n\t */\r\n\tpublic setName(name: string, variantId?: UmbVariantId): void {\r\n\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n\t\t// @ts-ignore\r\n\t\t// TODO: fix type error\r\n\t\tthis._data.updateVariantData(variantId ?? UmbVariantId.CreateInvariant(), { name });\r\n\t}\r\n\r\n\t/**\r\n\t * Get an observable for the name of a variant\r\n\t * @param {UmbVariantId} [variantId] - The variant id\r\n\t * @returns {Observable<string>} - The name of the variant\r\n\t * @memberof UmbContentDetailWorkspaceContextBase\r\n\t */\r\n\tpublic name(variantId?: UmbVariantId): Observable<string> {\r\n\t\treturn this._data.createObservablePartOfCurrent(\r\n\t\t\t(data) => data?.variants?.find((x) => variantId?.compare(x))?.name ?? '',\r\n\t\t);\r\n\t}\r\n\r\n\t/* Variants */\r\n\r\n\t/**\r\n\t * Get whether the content varies by culture\r\n\t * @returns { boolean | undefined } - If the content varies by culture\r\n\t * @memberof UmbContentDetailWorkspaceContextBase\r\n\t */\r\n\tpublic getVariesByCulture(): boolean | undefined {\r\n\t\treturn this.#variesByCulture;\r\n\t}\r\n\r\n\t/**\r\n\t * Get whether the content varies by segment\r\n\t * @returns {boolean | undefined} - If the content varies by segment\r\n\t * @memberof UmbContentDetailWorkspaceContextBase\r\n\t */\r\n\tpublic getVariesBySegment(): boolean | undefined {\r\n\t\treturn this.#variesBySegment;\r\n\t}\r\n\r\n\t/**\r\n\t * Get whether the content varies\r\n\t * @returns { boolean | undefined } - If the content varies\r\n\t * @memberof UmbContentDetailWorkspaceContextBase\r\n\t */\r\n\tpublic getVaries(): boolean | undefined {\r\n\t\treturn this.#varies;\r\n\t}\r\n\r\n\t/**\r\n\t * Get the variant by the given variantId\r\n\t * @param {UmbVariantId} variantId - The variant id\r\n\t * @returns { Observable<VariantModelType | undefined> } - The variant or undefined if not found\r\n\t * @memberof UmbContentDetailWorkspaceContextBase\r\n\t */\r\n\tpublic variantById(variantId: UmbVariantId): Observable<VariantModelType | undefined> {\r\n\t\treturn this._data.createObservablePartOfCurrent((data) => data?.variants?.find((x) => variantId.compare(x)));\r\n\t}\r\n\r\n\t/**\r\n\t * Get the variant by the given variantId\r\n\t * @param {UmbVariantId} variantId - The variant id\r\n\t * @returns { VariantModelType | undefined } - The variant or undefined if not found\r\n\t * @memberof UmbContentDetailWorkspaceContextBase\r\n\t */\r\n\tpublic getVariant(variantId: UmbVariantId): VariantModelType | undefined {\r\n\t\treturn this._data.getCurrent()?.variants?.find((x) => variantId.compare(x));\r\n\t}\r\n\r\n\tpublic getVariants(): Array<VariantModelType> | undefined {\r\n\t\treturn this._data.getCurrent()?.variants;\r\n\t}\r\n\r\n\t/**\r\n\t * Observe the property type\r\n\t * @param {string} propertyId - The id of the property\r\n\t * @returns {Promise<Observable<UmbPropertyTypeModel | undefined>>} - An observable for the property type\r\n\t * @memberof UmbContentDetailWorkspaceContextBase\r\n\t */\r\n\tpublic async propertyStructureById(propertyId: string): Promise<Observable<UmbPropertyTypeModel | undefined>> {\r\n\t\treturn this.structure.propertyStructureById(propertyId);\r\n\t}\r\n\r\n\t/* Values */\r\n\r\n\t/**\r\n\t * Get the values of the content\r\n\t * @returns {Array<UmbElementValueModel> | undefined} - The values of the content\r\n\t * @memberof UmbContentDetailWorkspaceContextBase\r\n\t */\r\n\tpublic getValues(): Array<UmbElementValueModel> | undefined {\r\n\t\treturn this._data.getCurrent()?.values;\r\n\t}\r\n\r\n\t/**\r\n\t * @function propertyValueByAlias\r\n\t * @param {string} propertyAlias - The alias of the property\r\n\t * @param {UmbVariantId} variantId - The variant\r\n\t * @returns {Promise<Observable<ReturnType | undefined> | undefined>} - An observable for the value of the property\r\n\t * @description Get an Observable for the value of this property.\r\n\t */\r\n\tpublic async propertyValueByAlias<PropertyValueType = unknown>(\r\n\t\tpropertyAlias: string,\r\n\t\tvariantId?: UmbVariantId,\r\n\t): Promise<Observable<PropertyValueType | undefined> | undefined> {\r\n\t\treturn this._data.createObservablePartOfCurrent(\r\n\t\t\t(data) =>\r\n\t\t\t\tdata?.values?.find((x) => x?.alias === propertyAlias && (variantId ? variantId.compare(x) : true))\r\n\t\t\t\t\t?.value as PropertyValueType,\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Get the current value of the property with the given alias and variantId.\r\n\t * @param {string} alias - The alias of the property\r\n\t * @param {UmbVariantId | undefined} variantId - The variant id of the property\r\n\t * @returns {ReturnType | undefined} The value or undefined if not set or found.\r\n\t */\r\n\tpublic getPropertyValue<ReturnType = unknown>(alias: string, variantId?: UmbVariantId) {\r\n\t\tconst currentData = this._data.getCurrent();\r\n\t\tif (currentData) {\r\n\t\t\tconst newDataSet = currentData.values?.find(\r\n\t\t\t\t(x) => x.alias === alias && (variantId ? variantId.compare(x) : true),\r\n\t\t\t);\r\n\t\t\treturn newDataSet?.value as ReturnType;\r\n\t\t}\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * Set the value of the property with the given alias and variantId.\r\n\t * @template ValueType\r\n\t * @param {string} alias - The alias of the property\r\n\t * @param {ValueType} value - The value to set\r\n\t * @param {UmbVariantId} [variantId] - The variant id of the property\r\n\t * @memberof UmbContentDetailWorkspaceContextBase\r\n\t */\r\n\tpublic async setPropertyValue<ValueType = unknown>(alias: string, value: ValueType, variantId?: UmbVariantId) {\r\n\t\tthis.initiatePropertyValueChange();\r\n\t\tvariantId ??= UmbVariantId.CreateInvariant();\r\n\t\tconst property = await this.structure.getPropertyStructureByAlias(alias);\r\n\r\n\t\tif (!property) {\r\n\t\t\tthrow new Error(`Property alias \"${alias}\" not found.`);\r\n\t\t}\r\n\r\n\t\t// the getItemByUnique is a async method that first resolves once the item is loaded.\r\n\t\tconst editorAlias = (await this.#dataTypeItemManager.getItemByUnique(property.dataType.unique))\r\n\t\t\t.propertyEditorSchemaAlias;\r\n\t\t// This means if its not loaded this will never resolve and the error below will never happen.\r\n\t\tif (!editorAlias) {\r\n\t\t\tthrow new Error(`Editor Alias of \"${property.dataType.unique}\" not found.`);\r\n\t\t}\r\n\r\n\t\t// Notice the order of the properties is important for our JSON String Compare function. [NL]\r\n\t\tconst entry = { editorAlias, ...variantId.toObject(), alias, value } as UmbElementValueModel;\r\n\r\n\t\tconst currentData = this.getData();\r\n\t\tif (currentData) {\r\n\t\t\tconst values = appendToFrozenArray(\r\n\t\t\t\tcurrentData.values ?? [],\r\n\t\t\t\tentry,\r\n\t\t\t\t(x) => x.alias === alias && variantId!.compare(x),\r\n\t\t\t);\r\n\r\n\t\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n\t\t\t// @ts-ignore\r\n\t\t\t// TODO: fix type error\r\n\t\t\tthis._data.updateCurrent({ values });\r\n\r\n\t\t\t// TODO: Ideally we should move this type of logic to the act of saving [NL]\r\n\t\t\tthis._data.ensureVariantData(variantId);\r\n\t\t}\r\n\t\tthis.finishPropertyValueChange();\r\n\t}\r\n\r\n\tpublic initiatePropertyValueChange() {\r\n\t\tthis._data.initiatePropertyValueChange();\r\n\t}\r\n\r\n\tpublic finishPropertyValueChange = () => {\r\n\t\tthis._data.finishPropertyValueChange();\r\n\t};\r\n\r\n\t/**\r\n\t * Gets the changed variant ids\r\n\t * @returns {Array<UmbVariantId>} - The changed variant ids\r\n\t * @memberof UmbContentDetailWorkspaceContextBase\r\n\t */\r\n\tpublic getChangedVariants(): Array<UmbVariantId> {\r\n\t\treturn this._data.getChangedVariants();\r\n\t}\r\n\r\n\tprotected async _determineVariantOptions(): Promise<{\r\n\t\toptions: VariantOptionModelType[];\r\n\t\tselected: string[];\r\n\t}> {\r\n\t\tconst options = await firstValueFrom(this.variantOptions);\r\n\r\n\t\tconst activeVariants = this.splitView.getActiveVariants();\r\n\t\tconst activeVariantIds = activeVariants.map((activeVariant) => UmbVariantId.Create(activeVariant));\r\n\t\tconst changedVariantIds = this._data.getChangedVariants();\r\n\t\tconst selectedVariantIds = activeVariantIds.concat(changedVariantIds);\r\n\r\n\t\t// Selected can contain entries that are not part of the options, therefor the modal filters selection based on options.\r\n\t\tconst readOnlyCultures = this.readOnlyState.getStates().map((s) => s.variantId.culture);\r\n\t\tlet selected = selectedVariantIds.map((x) => x.toString()).filter((v, i, a) => a.indexOf(v) === i);\r\n\t\tselected = selected.filter((x) => readOnlyCultures.includes(x) === false);\r\n\r\n\t\treturn {\r\n\t\t\toptions,\r\n\t\t\tselected,\r\n\t\t};\r\n\t}\r\n\r\n\tprotected _saveableVariantsFilter = (option: VariantOptionModelType) => {\r\n\t\tconst readOnlyCultures = this.readOnlyState.getStates().map((s) => s.variantId.culture);\r\n\t\treturn readOnlyCultures.includes(option.culture) === false;\r\n\t};\r\n\r\n\t/* validation */\r\n\t/**\r\n\t * Run the mandatory validation for the save data\r\n\t * @deprecated Use the public runMandatoryValidationForSaveData instead. Will be removed in v. 17.\r\n\t * @protected\r\n\t * @param {DetailModelType} saveData - The data to validate\r\n\t * @memberof UmbContentDetailWorkspaceContextBase\r\n\t */\r\n\tprotected async _runMandatoryValidationForSaveData(saveData: DetailModelType, variantIds: Array<UmbVariantId> = []) {\r\n\t\tnew UmbDeprecation({\r\n\t\t\tremoveInVersion: '17',\r\n\t\t\tdeprecated: '_runMandatoryValidationForSaveData',\r\n\t\t\tsolution: 'Use the public runMandatoryValidationForSaveData instead.',\r\n\t\t}).warn();\r\n\t\tthis.runMandatoryValidationForSaveData(saveData, variantIds);\r\n\t}\r\n\r\n\t/**\r\n\t * Run the mandatory validation for the save data\r\n\t * @param {DetailModelType} saveData - The data to validate\r\n\t * @memberof UmbContentDetailWorkspaceContextBase\r\n\t */\r\n\tpublic async runMandatoryValidationForSaveData(saveData: DetailModelType, variantIds: Array<UmbVariantId> = []) {\r\n\t\t// Check that the data is valid before we save it.\r\n\t\tconst missingVariants = variantIds.filter((variant) => {\r\n\t\t\treturn !saveData.variants.some((y) => variant.compare(y));\r\n\t\t});\r\n\t\tif (missingVariants.length > 0) {\r\n\t\t\tthrow new Error('One or more selected variants have not been created');\r\n\t\t}\r\n\t\t// Check variants have a name:\r\n\t\tconst variantsWithoutAName = saveData.variants.filter((x) => !x.name);\r\n\t\tif (variantsWithoutAName.length > 0) {\r\n\t\t\tconst validationContext = await this.getContext(UMB_VALIDATION_CONTEXT);\r\n\t\t\tvariantsWithoutAName.forEach((variant) => {\r\n\t\t\t\tvalidationContext.messages.addMessage(\r\n\t\t\t\t\t'client',\r\n\t\t\t\t\t`$.variants[${UmbDataPathVariantQuery(variant)}].name`,\r\n\t\t\t\t\tUMB_VALIDATION_EMPTY_LOCALIZATION_KEY,\r\n\t\t\t\t);\r\n\t\t\t});\r\n\t\t\tthrow new Error('All variants must have a name');\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Ask the server to validate the save data\r\n\t * @param {DetailModelType} saveData - The data to validate\r\n\t * @param {Array<UmbVariantId>} variantIds - The variant ids to validate\r\n\t * @memberof UmbContentDetailWorkspaceContextBase\r\n\t */\r\n\tpublic async askServerToValidate(saveData: DetailModelType, variantIds: Array<UmbVariantId>) {\r\n\t\tif (this.#validationRepositoryClass) {\r\n\t\t\t// Create the validation repository if it does not exist. (we first create this here when we need it) [NL]\r\n\t\t\tthis.#validationRepository ??= new this.#validationRepositoryClass(this);\r\n\r\n\t\t\t// We ask the server first to get a concatenated set of validation messages. So we see both front-end and back-end validation messages [NL]\r\n\t\t\tif (this.getIsNew()) {\r\n\t\t\t\tconst parent = this.getParent();\r\n\t\t\t\tif (!parent) throw new Error('Parent is not set');\r\n\t\t\t\tawait this.#serverValidation.askServerForValidation(\r\n\t\t\t\t\tsaveData,\r\n\t\t\t\t\tthis.#validationRepository.validateCreate(saveData, parent.unique),\r\n\t\t\t\t);\r\n\t\t\t} else {\r\n\t\t\t\tawait this.#serverValidation.askServerForValidation(\r\n\t\t\t\t\tsaveData,\r\n\t\t\t\t\tthis.#validationRepository.validateSave(saveData, variantIds),\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Request a submit of the workspace, in the case of Document Workspaces the validation does not need to be valid for this to be submitted.\r\n\t * @returns {Promise<void>} a promise which resolves once it has been completed.\r\n\t */\r\n\tpublic override requestSubmit() {\r\n\t\treturn this._handleSubmit();\r\n\t}\r\n\r\n\tpublic override submit() {\r\n\t\treturn this._handleSubmit();\r\n\t}\r\n\r\n\t/**\r\n\t * Get the data to save\r\n\t * @param {Array<UmbVariantId>} variantIds - The variant ids to save\r\n\t * @returns {Promise<DetailModelType>}  {Promise<DetailModelType>}\r\n\t * @memberof UmbContentDetailWorkspaceContextBase\r\n\t */\r\n\tpublic constructSaveData(variantIds: Array<UmbVariantId>): Promise<DetailModelType> {\r\n\t\treturn this._data.constructData(variantIds);\r\n\t}\r\n\r\n\tprotected async _handleSubmit() {\r\n\t\tconst data = this.getData();\r\n\t\tif (!data) {\r\n\t\t\tthrow new Error('Data is missing');\r\n\t\t}\r\n\r\n\t\tconst { options, selected } = await this._determineVariantOptions();\r\n\r\n\t\tlet variantIds: Array<UmbVariantId> = [];\r\n\r\n\t\t// If there is only one variant, we don't need to open the modal.\r\n\t\tif (options.length === 0) {\r\n\t\t\tthrow new Error('No variants are available');\r\n\t\t} else if (options.length === 1) {\r\n\t\t\t// If only one option we will skip ahead and save the content with the only variant available:\r\n\t\t\tvariantIds.push(UmbVariantId.Create(options[0]));\r\n\t\t} else if (this.#saveModalToken) {\r\n\t\t\t// If there are multiple variants, we will open the modal to let the user pick which variants to save.\r\n\t\t\tconst modalManagerContext = await this.getContext(UMB_MODAL_MANAGER_CONTEXT);\r\n\t\t\tconst result = await modalManagerContext\r\n\t\t\t\t.open(this, this.#saveModalToken, {\r\n\t\t\t\t\tdata: {\r\n\t\t\t\t\t\toptions,\r\n\t\t\t\t\t\tpickableFilter: this._saveableVariantsFilter,\r\n\t\t\t\t\t},\r\n\t\t\t\t\tvalue: { selection: selected },\r\n\t\t\t\t})\r\n\t\t\t\t.onSubmit()\r\n\t\t\t\t.catch(() => undefined);\r\n\r\n\t\t\tif (!result?.selection.length) return;\r\n\r\n\t\t\tvariantIds = result?.selection.map((x) => UmbVariantId.FromString(x)) ?? [];\r\n\t\t} else {\r\n\t\t\tthrow new Error('No variant picker modal token is set. There are multiple variants to save. Cannot proceed.');\r\n\t\t}\r\n\r\n\t\tconst saveData = await this.constructSaveData(variantIds);\r\n\t\tawait this.runMandatoryValidationForSaveData(saveData, variantIds);\r\n\t\tif (this.#validateOnSubmit) {\r\n\t\t\tawait this.askServerToValidate(saveData, variantIds);\r\n\t\t\treturn this.validateAndSubmit(\r\n\t\t\t\tasync () => {\r\n\t\t\t\t\treturn this.performCreateOrUpdate(variantIds, saveData);\r\n\t\t\t\t},\r\n\t\t\t\tasync () => {\r\n\t\t\t\t\treturn this.invalidSubmit();\r\n\t\t\t\t},\r\n\t\t\t);\r\n\t\t} else {\r\n\t\t\tawait this.performCreateOrUpdate(variantIds, saveData);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Perform the create or update of the content\r\n\t * @deprecated Use the public performCreateOrUpdate instead. Will be removed in v. 17.\r\n\t * @protected\r\n\t * @param {Array<UmbVariantId>} variantIds\r\n\t * @param {DetailModelType} saveData\r\n\t * @memberof UmbContentDetailWorkspaceContextBase\r\n\t */\r\n\tprotected async _performCreateOrUpdate(variantIds: Array<UmbVariantId>, saveData: DetailModelType) {\r\n\t\tawait this.performCreateOrUpdate(variantIds, saveData);\r\n\t}\r\n\r\n\t/**\r\n\t * Perform the create or update of the content\r\n\t * @param {Array<UmbVariantId>} variantIds - The variant ids to save\r\n\t * @param {DetailModelType} saveData - The data to save\r\n\t * @memberof UmbContentDetailWorkspaceContextBase\r\n\t */\r\n\tpublic async performCreateOrUpdate(variantIds: Array<UmbVariantId>, saveData: DetailModelType) {\r\n\t\tif (this.getIsNew()) {\r\n\t\t\tawait this.#create(variantIds, saveData);\r\n\t\t} else {\r\n\t\t\tawait this.#update(variantIds, saveData);\r\n\t\t}\r\n\t}\r\n\r\n\tasync #create(variantIds: Array<UmbVariantId>, saveData: DetailModelType) {\r\n\t\tif (!this._detailRepository) throw new Error('Detail repository is not set');\r\n\r\n\t\tconst parent = this.getParent();\r\n\t\tif (!parent) throw new Error('Parent is not set');\r\n\r\n\t\tconst { data, error } = await this._detailRepository.create(saveData, parent.unique);\r\n\t\tif (!data || error) {\r\n\t\t\tthrow new Error('Error creating content');\r\n\t\t}\r\n\r\n\t\tconst variantIdsIncludingInvariant = [...variantIds, UmbVariantId.CreateInvariant()];\r\n\r\n\t\t// Only update the variants that was chosen to be saved:\r\n\t\tconst persistedData = this._data.getCurrent();\r\n\t\tconst newPersistedData = await new UmbMergeContentVariantDataController(this).process(\r\n\t\t\tpersistedData,\r\n\t\t\tdata,\r\n\t\t\tvariantIds,\r\n\t\t\tvariantIdsIncludingInvariant,\r\n\t\t);\r\n\t\tthis._data.setPersisted(newPersistedData);\r\n\r\n\t\t// Only update the variants that was chosen to be saved:\r\n\t\tconst currentData = this._data.getCurrent();\r\n\t\tconst newCurrentData = await new UmbMergeContentVariantDataController(this).process(\r\n\t\t\tcurrentData,\r\n\t\t\tdata,\r\n\t\t\tvariantIds,\r\n\t\t\tvariantIdsIncludingInvariant,\r\n\t\t);\r\n\t\tthis._data.setCurrent(newCurrentData);\r\n\r\n\t\tconst eventContext = await this.getContext(UMB_ACTION_EVENT_CONTEXT);\r\n\t\tconst event = new UmbRequestReloadChildrenOfEntityEvent({\r\n\t\t\tentityType: parent.entityType,\r\n\t\t\tunique: parent.unique,\r\n\t\t});\r\n\t\teventContext.dispatchEvent(event);\r\n\t\tthis.setIsNew(false);\r\n\r\n\t\tthis._closeModal();\r\n\t}\r\n\r\n\tasync #update(variantIds: Array<UmbVariantId>, saveData: DetailModelType) {\r\n\t\tif (!this._detailRepository) throw new Error('Detail repository is not set');\r\n\r\n\t\tconst { data, error } = await this._detailRepository.save(saveData);\r\n\t\tif (!data || error) {\r\n\t\t\tthrow new Error('Error saving content');\r\n\t\t}\r\n\r\n\t\tconst variantIdsIncludingInvariant = [...variantIds, UmbVariantId.CreateInvariant()];\r\n\r\n\t\t// Only update the variants that was chosen to be saved:\r\n\t\tconst persistedData = this._data.getCurrent();\r\n\t\tconst newPersistedData = await new UmbMergeContentVariantDataController(this).process(\r\n\t\t\tpersistedData,\r\n\t\t\tdata,\r\n\t\t\tvariantIds,\r\n\t\t\tvariantIdsIncludingInvariant,\r\n\t\t);\r\n\t\tthis._data.setPersisted(newPersistedData);\r\n\r\n\t\t// Only update the variants that was chosen to be saved:\r\n\t\tconst currentData = this._data.getCurrent();\r\n\t\tconst newCurrentData = await new UmbMergeContentVariantDataController(this).process(\r\n\t\t\tcurrentData,\r\n\t\t\tdata,\r\n\t\t\tvariantIds,\r\n\t\t\tvariantIdsIncludingInvariant,\r\n\t\t);\r\n\t\tthis._data.setCurrent(newCurrentData);\r\n\r\n\t\tconst unique = this.getUnique()!;\r\n\t\tconst entityType = this.getEntityType();\r\n\r\n\t\tconst eventContext = await this.getContext(UMB_ACTION_EVENT_CONTEXT);\r\n\t\tconst structureEvent = new UmbRequestReloadStructureForEntityEvent({ unique, entityType });\r\n\t\teventContext.dispatchEvent(structureEvent);\r\n\r\n\t\tconst updatedEvent = new UmbEntityUpdatedEvent({\r\n\t\t\tunique,\r\n\t\t\tentityType,\r\n\t\t\teventUnique: this._workspaceEventUnique,\r\n\t\t});\r\n\r\n\t\teventContext.dispatchEvent(updatedEvent);\r\n\r\n\t\tthis._closeModal();\r\n\t}\r\n\r\n\toverride resetState() {\r\n\t\tsuper.resetState();\r\n\t\tthis.readOnlyState.clear();\r\n\t}\r\n\r\n\tabstract getContentTypeUnique(): string | undefined;\r\n\r\n\tabstract createPropertyDatasetContext(\r\n\t\thost: UmbControllerHost,\r\n\t\tvariantId: UmbVariantId,\r\n\t): UmbContentPropertyDatasetContext<DetailModelType, ContentTypeDetailModelType, VariantModelType>;\r\n\r\n\tpublic override destroy(): void {\r\n\t\tthis.structure.destroy();\r\n\t\tthis.#languageRepository.destroy();\r\n\t\tsuper.destroy();\r\n\t}\r\n}\r\n"],"names":["UMB_CONTENT_HAS_PROPERTIES_WORKSPACE_CONDITION","UMB_CONTENT_SECTION_ALIAS","defaultCompareVariantMethod","a","b","UmbMergeContentVariantDataController","UmbControllerBase","persistedData","currentData","selectedVariants","variantsToStore","result","#processValues","#processVariants","persistedValues","draftValues","uniqueValues","n","self","v","value","persistedValue","x","UmbVariantId","draftValue","#processValue","editorAlias","manifest","umbExtensionsRegistry","api","createExtensionApi","newValue","persistedValuesHolder","values","valuesIndex","persistedVariantsHolder","persistedVariants","draftVariants","compare","i","persistedVariant","valueObjectCompare","umbVariantObjectCompare","UmbElementWorkspaceDataManager","UmbEntityWorkspaceDataManager","#updateLock","#triggerPropertyValueChanges","vary","invariantVariantId","data","UmbContentWorkspaceDataManager","#variantScaffold","host","variantScaffold","variantId","update","variant","newVariants","appendToFrozenArray","persisted","current","changedVariants","jsonStringComparison","changedProperties","IsContentPropertyDatasetContext","context","UMB_CONTENT_PROPERTY_DATASET_CONTEXT","UmbContextToken","UmbElementPropertyDatasetContext","UmbContextBase","dataOwner","UMB_PROPERTY_DATASET_CONTEXT","#propertyVariantIdMap","UmbBasicState","#readOnly","UmbBooleanState","#variantId","#propertyVariantIdPromise","resolve","#propertyVariantIdPromiseResolver","states","isReadOnly","state","props","map","prop","#createPropertyVariantId","property","#propertiesObservable","mergeObservables","#mergeVariantIdsAndValues","f","propertyAlias","createObservablePart","classEqualMemoization","propertyVariantId","propVariantId","UmbContentPropertyDatasetContext","#pathAddendum","UmbRoutePathAddendumContext","#currentVariant","UmbObjectState","variantInfo","name","UmbContentDetailWorkspaceContextBase","UmbEntityDetailWorkspaceContextBase","args","UmbReadOnlyVariantStateManager","#dataTypeItemManager","UmbDataTypeItemRepositoryManager","UmbWorkspaceSplitViewManager","#languageRepository","UmbLanguageCollectionRepository","#languages","UmbArrayState","#serverValidation","UmbServerModelValidatorContext","option","s","#saveModalToken","#contentTypePropertyName","contentTypeDetailRepository","#validationRepositoryClass","#validateOnSubmit","UmbContentTypeStructureManager","varies","variants","languages","language","UMB_INVARIANT_CULTURE","UmbVariantValuesValidationPathTranslator","UmbVariantsValidationPathTranslator","#varies","#variesByCulture","#variesBySegment","dataTypeUniques","#validationRepository","cutlures","segments","repo","UmbDataTypeDetailRepository","propertyTypes","valueDefinitions","dataType","controller","UmbPropertyValuePresetVariantBuilderController","propertyId","alias","entry","options","firstValueFrom","activeVariantIds","activeVariant","changedVariantIds","selectedVariantIds","readOnlyCultures","selected","saveData","variantIds","UmbDeprecation","y","variantsWithoutAName","validationContext","UMB_VALIDATION_CONTEXT","UmbDataPathVariantQuery","UMB_VALIDATION_EMPTY_LOCALIZATION_KEY","parent","UMB_MODAL_MANAGER_CONTEXT","#create","#update","error","variantIdsIncludingInvariant","newPersistedData","newCurrentData","eventContext","UMB_ACTION_EVENT_CONTEXT","event","UmbRequestReloadChildrenOfEntityEvent","unique","entityType","structureEvent","UmbRequestReloadStructureForEntityEvent","updatedEvent","UmbEntityUpdatedEvent"],"mappings":"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"}